/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Please refer to the README for information about making permanent changes.  #
################################################################################
*/

#include "QmlHydra.h"


///
//  Set node nickname; this is saved persistently in the Hydra configuration
//  file.                                                                   
void QmlHydra::setNickname (const QString &nickname) {
    hydra_set_nickname (self, nickname.toUtf8().data());
};

///
//  Return our node nickname, as previously stored in hydra.cfg, or set by 
//  the hydra_set_nickname() method. Caller must free returned string using
//  zstr_free ().                                                          
const QString QmlHydra::nickname () {
    return QString (hydra_nickname (self));
};

///
//  Set the trace level to animation of main actors; this is helpful to
//  debug the Hydra protocol flow.                                     
void QmlHydra::setAnimate () {
    hydra_set_animate (self);
};

///
//  Set the trace level to animation of all actors including those used in
//  security and discovery. Use this to collect diagnostic logs.          
void QmlHydra::setVerbose () {
    hydra_set_verbose (self);
};

///
//  By default, Hydra needs a network interface capable of broadcast UDP  
//  traffic, e.g. WiFi or LAN interface. To run nodes on a stand-alone PC,
//  set the local IPC option. The node will then do gossip discovery over 
//  IPC. Gossip discovery needs at exactly one node to be running in a    
//  directory called ".hydra".                                            
void QmlHydra::setLocalIpc () {
    hydra_set_local_ipc (self);
};

///
//  By default, Hydra uses your hostname via zbeacon. Use this function to
//  set some other hostname. Useful when using VMs, containers, etc.      
void QmlHydra::setHostname (const QString &hostname) {
    hydra_set_hostname (self, hostname.toUtf8().data());
};

///
//  Start node. When you start a node it begins discovery and post exchange.
//  Returns 0 if OK, -1 if it wasn't possible to start the node.            
int QmlHydra::start () {
    return hydra_start (self);
};

///
//  Return next available post, if any. Does not block. If there are no posts
//  waiting, returns NULL. The caller can read the post using the hydra_post 
//  API, and must destroy the post when done with it.                        
QmlHydraPost *QmlHydra::fetch () {
    QmlHydraPost *retQ_ = new QmlHydraPost ();
    retQ_->self = hydra_fetch (self);
    return retQ_;
};

///
//  Store a new post provided as a null-terminated string. Returns post ID for
//  the newly created post, or NULL if it was impossible to store the post.   
//  Caller must free post ID when finished with it.                           
QString QmlHydra::storeString (const QString &subject, const QString &parentId, const QString &mimeType, const QString &content) {
    char *retStr_ = hydra_store_string (self, subject.toUtf8().data(), parentId.toUtf8().data(), mimeType.toUtf8().data(), content.toUtf8().data());
    QString retQStr_ = QString (retStr_);
    free (retStr_);
    return retQStr_;
};

///
//  Store a new post located in a file somewhere on disk. Returns post ID for
//  the newly created post, or NULL if it was impossible to store the post.  
//  Caller must free post ID when finished with it.                          
QString QmlHydra::storeFile (const QString &subject, const QString &parentId, const QString &mimeType, const QString &filename) {
    char *retStr_ = hydra_store_file (self, subject.toUtf8().data(), parentId.toUtf8().data(), mimeType.toUtf8().data(), filename.toUtf8().data());
    QString retQStr_ = QString (retStr_);
    free (retStr_);
    return retQStr_;
};

///
//  Store a new post provided as a chunk of data. Returns post ID for      
//  the newly created post, or NULL if it was impossible to store the post.
//  Caller must free post ID when finished with it.                        
QString QmlHydra::storeChunk (const QString &subject, const QString &parentId, const QString &mimeType, zchunk_t *chunk) {
    char *retStr_ = hydra_store_chunk (self, subject.toUtf8().data(), parentId.toUtf8().data(), mimeType.toUtf8().data(), chunk);
    QString retQStr_ = QString (retStr_);
    free (retStr_);
    return retQStr_;
};


QObject* QmlHydra::qmlAttachedProperties(QObject* object) {
    return new QmlHydraAttached(object);
}


///
//  Return the Hydra version for run-time API detection
void QmlHydraAttached::version (int *major, int *minor, int *patch) {
    hydra_version (major, minor, patch);
};

///
//  Self test of this class
void QmlHydraAttached::test (bool verbose) {
    hydra_test (verbose);
};

///
//  Constructor, creates a new Hydra node. Note that until you start the  
//  node it is silent and invisible to other nodes on the network. You may
//  specify the working directory, which defaults to .hydra in the current
//  working directory. Creates the working directory if necessary.        
QmlHydra *QmlHydraAttached::construct (const QString &directory) {
    QmlHydra *qmlSelf = new QmlHydra ();
    qmlSelf->self = hydra_new (directory.toUtf8().data());
    return qmlSelf;
};

///
//  Destructor, destroys a Hydra node. When you destroy a node, any posts
//  it is sending or receiving will be discarded.                        
void QmlHydraAttached::destruct (QmlHydra *qmlSelf) {
    hydra_destroy (&qmlSelf->self);
};

/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Please refer to the README for information about making permanent changes.  #
################################################################################
*/
