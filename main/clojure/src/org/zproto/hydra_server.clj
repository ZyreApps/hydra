;;  =========================================================================
;;    hydra_server
;;
;;    ** WARNING *************************************************************
;;    THIS SOURCE FILE IS 100% GENERATED. If you edit this file, you will lose
;;    your changes at the next build cycle. This is great for temporary printf
;;    statements. DO NOT MAKE ANY CHANGES YOU WISH TO KEEP. The correct places
;;    for commits are:
;;
;;     * The XML model used for this code generation: hydra_server.xml, or
;;     * The code generation script that built this file: zproto_server_clj
;;    ************************************************************************
;;    Copyright (c) the Contributors as noted in the AUTHORS file.       
;;    This file is part of zbroker, the ZeroMQ broker project.           
;;                                                                       
;;    This Source Code Form is subject to the terms of the Mozilla Public
;;    License, v. 2.0. If a copy of the MPL was not distributed with this
;;    file, You can obtain one at http://mozilla.org/MPL/2.0/.           
;;    =========================================================================

(ns org.zproto.hydra-server
  (:refer-clojure :exclude [send])
  (:require [zeromq.zmq :as zmq]
            [org.zproto.hydra-msg :as msg])
  (:import  [org.zproto HydraMsg]))

;;
;; The HydraServerBackend Protocol specifies
;; the actions that have to be implemented for a functional server.
;; Currently, return values are expected to match be the arguments to
;; the returning send function as a vector.
;;
(defprotocol HydraServerBackend
  (get-latest-post [this])
  (get-all-tags [this])
  (get-single-tag [this tag])
  (get-single-post [this post-id]))

;; currently just a catch-all no op.
(defn terminate [& _])

(defn next-state [to-state]
  (fn [{:keys [state]} routing-id _]
    (swap! state assoc-in [routing-id] to-state)))

;;
;; Wrapper function that facilitates correct parameter
;; assignments to the send-fn depending on the shape
;; of the response generated by the backend
;;
(defn send [send-fn]
   (fn [{:keys [socket]} routing-id response]
      (cond
        (vector? response) (apply send-fn socket routing-id response)
        (instance? HydraMsg response) (send-fn socket routing-id)
        :else (send-fn socket routing-id response))))

;;
;; Creates a function that calls the backend action-fn with the
;; appropriate parameters extracted from the msg.
;;
(defmacro action [action-fn & extractors]
  `(fn [{:keys [~'backend]} ~'_ ~'msg]
     (~action-fn ~'backend ~@(mapv (fn [e] (list e 'msg)) extractors))))

;;
;; Encodes the transition from states via events through
;; a number of actions. This is pretty close to the structure
;; given in the model, super states are expanded.
;;
(def state-events {
  :start {
    HydraMsg/HELLO [ (action get-latest-post) (send msg/hello-ok) (next-state :connected) ]
    :* [ (send msg/invalid) (action terminate) ]
  }
  :connected {
    HydraMsg/GET_TAGS [ (action get-all-tags) (send msg/get-tags-ok) ]
    HydraMsg/GET_TAG [ (action get-single-tag .tag) (send msg/get-tag-ok) ]
    HydraMsg/GET_POST [ (action get-single-post .post_id) (send msg/get-post-ok) ]
    HydraMsg/GOODBYE [ (send msg/goodbye-ok) (action terminate) ]
    :* [ (send msg/invalid) (action terminate) ]
  }
  :external {
    :* [ (send msg/invalid) (action terminate) ]
  }})

(def determine-actions
  (memoize
   (fn [state event-id]
     (or (get-in state-events [state event-id])
         (get-in state-events [state :*])))))

(defn maybe-setup-session [state routing-id]
  (if (get state routing-id)
    state
    (assoc state routing-id :start)))

(defn match-msg
  [{:keys [state] :as server} ^HydraMsg msg]
  (let [id (.id msg)
        routing-id (.routingId msg)
        initialized-state (-> (swap! state maybe-setup-session routing-id)
                              (get routing-id))]
    (reduce (fn [client-state handler]
               (handler server routing-id client-state))
            msg
            (determine-actions initialized-state id))))

(defrecord Server [socket state backend])

(defn server-loop
  [socket backend]
  (let [server (Server. socket (atom {}) backend)]
    (loop []
      (when-let [received (msg/recv socket)]
        (try
          (match-msg server received)
          (catch Exception e
            (.printStackTrace e))))
      (if (not (.isInterrupted (Thread/currentThread)))
        (recur)
        (println "Server shutdown")))))
