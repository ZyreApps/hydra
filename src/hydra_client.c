/*  =========================================================================
    hydra_client - Hydra Client

    Copyright (c) the Contributors as noted in the AUTHORS file.       
    This file is part of zbroker, the ZeroMQ broker project.           
                                                                       
    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.           
    =========================================================================
*/

/*
@header
    This is a client for the Hydra protocol that connects, synchronizes,
    and then terminates. It's not a general client API.
@discuss
    Generated by zproto and implements a background actor that manages the
    connection to the Hydra server.
@end
*/

#include "hydra_classes.h"

//  Forward reference to method arguments structure
typedef struct _client_args_t client_args_t;

//  This structure defines the context for a client connection
typedef struct {
    //  These properties must always be present in the client_t
    //  and are set by the generated engine. The cmdpipe gets
    //  messages sent to the actor; the msgpipe may be used for
    //  faster asynchronous message flows.
    zsock_t *cmdpipe;           //  Command pipe to/from caller API
    zsock_t *msgpipe;           //  Message pipe to/from caller API
    zsock_t *dealer;            //  Socket to talk to server
    hydra_proto_t *message;     //  Message from and to server
    client_args_t *args;        //  Arguments from methods

    //  Custom properties
    zconfig_t *config;          //  Configuration tree
} client_t;

//  Include the generated client engine
#include "hydra_client_engine.inc"

//  Allocate properties and structures for a new client instance.
//  Return 0 if OK, -1 if failed

static int
client_initialize (client_t *self)
{
    //  Get node identity from config file, or generate new identity
    self->config = zconfig_load ("hydra.cfg");
    assert (self->config);
    return 0;
}

//  Free properties and structures for a client instance

static void
client_terminate (client_t *self)
{
    zconfig_destroy (&self->config);
}


//  ---------------------------------------------------------------------------
//  use_connect_timeout
//

static void
use_connect_timeout (client_t *self)
{
    engine_set_timeout (self, self->args->timeout);
}


//  ---------------------------------------------------------------------------
//  connect_to_server_endpoint
//

static void
connect_to_server_endpoint (client_t *self)
{
    if (zsock_connect (self->dealer, "%s", self->args->endpoint)) {
        engine_set_exception (self, bad_endpoint_event);
        zsys_warning ("could not connect to %s", self->args->endpoint);
    }
}


//  ---------------------------------------------------------------------------
//  set_client_identity
//

static void
set_client_identity (client_t *self)
{
    char *identity = zconfig_resolve (self->config, "/hydra/identity", NULL);
    char *nickname = zconfig_resolve (self->config, "/hydra/nickname", "");
    assert (identity);
    hydra_proto_set_identity (self->message, identity);
    hydra_proto_set_nickname (self->message, nickname);
}


//  ---------------------------------------------------------------------------
//  use_response_timeout
//

static void
use_response_timeout (client_t *self)
{
    engine_set_timeout (self, 1000);
}


//  ---------------------------------------------------------------------------
//  prepare_to_get_last_post
//

static void
prepare_to_get_last_post (client_t *self)
{
    //  Check if we already have the post
    const char *post_id = hydra_proto_post_id (self->message);
    if (*post_id) {
        char *filename = zsys_sprintf ("posts/%s", hydra_proto_post_id (self->message));
        if (zsys_file_exists (filename))
            engine_set_exception (self, have_post_event);
        zstr_free (&filename);
    }
    else
        engine_set_exception (self, got_nothing_event);
}


//  ---------------------------------------------------------------------------
//  store_the_post
//

static void
store_the_post (client_t *self)
{
    zsys_info ("receiving post=%s", hydra_proto_post_id (self->message));

    zconfig_t *post = zconfig_new ("root", NULL);
    zconfig_put (post, "/post/reply_to",  hydra_proto_reply_to  (self->message));
    zconfig_put (post, "/post/previous",  hydra_proto_previous  (self->message));
    zconfig_put (post, "/post/timestamp", hydra_proto_timestamp (self->message));
    zconfig_put (post, "/post/digest",    hydra_proto_digest    (self->message));
    zconfig_put (post, "/post/type",      hydra_proto_type      (self->message));
    char *filename = zsys_sprintf ("posts/%s", hydra_proto_post_id (self->message));
    if (zconfig_save (post, filename))
        zsys_error ("can't write post to %s", filename);
    zstr_free (&filename);

    if (*hydra_proto_digest (self->message)) {
        filename = zsys_sprintf ("content/%s", hydra_proto_digest (self->message));
        FILE *handle = fopen (filename, "wb");
        if (handle) {
            zchunk_t *chunk = hydra_proto_content (self->message);
            zsys_info (" - writing content size=%zd", zchunk_size (chunk));
            zchunk_write (chunk, handle);
            fclose (handle);
        }
        else
            zsys_error ("can't write content to %s", filename);
        zstr_free (&filename);
    }
    FILE *handle = fopen ("ledger.txt", "a");
    if (handle) {
        fprintf (handle, "%s\n", hydra_proto_post_id (self->message));
        fclose (handle);
    }
    else
        zsys_error ("can't write to ledger.txt: %s", strerror (errno));
}


//  ---------------------------------------------------------------------------
//  prepare_to_get_previous_post
//

static void
prepare_to_get_previous_post (client_t *self)
{
    if (*hydra_proto_previous (self->message))
        hydra_proto_set_post_id (self->message, hydra_proto_previous (self->message));
    else
        engine_set_exception (self, have_post_event);
}


//  ---------------------------------------------------------------------------
//  signal_success
//

static void
signal_success (client_t *self)
{
    zsock_send (self->cmdpipe, "si", "SUCCESS", 0);
}


//  ---------------------------------------------------------------------------
//  signal_incomplete
//

static void
signal_incomplete (client_t *self)
{
    zsock_send (self->cmdpipe, "sis", "FAILURE", -1, "Premature disconnection");
}


//  ---------------------------------------------------------------------------
//  signal_bad_endpoint
//

static void
signal_bad_endpoint (client_t *self)
{
    zsock_send (self->cmdpipe, "sis", "FAILURE", -1, "Bad server endpoint");
}


//  ---------------------------------------------------------------------------
//  signal_server_not_present
//

static void
signal_server_not_present (client_t *self)
{
    zsock_send (self->cmdpipe, "sis", "FAILURE", -1, "Server is not reachable");
}


//  ---------------------------------------------------------------------------
//  signal_internal_error
//

static void
signal_internal_error (client_t *self)
{
    zsock_send (self->cmdpipe, "sis", "FAILURE", -1, "Internal server error");
}


//  ---------------------------------------------------------------------------
//  Selftest

void
hydra_client_test (bool verbose)
{
    printf (" * hydra_client: ");
    if (verbose)
        printf ("\n");
    
    //  @selftest
    //  Start a server to test against, and bind to endpoint
    zactor_t *server = zactor_new (hydra_server, "hydra_client_test");
    if (verbose)
        zstr_send (server, "VERBOSE");
    zstr_sendx (server, "CONFIGURE", "hydra.cfg", NULL);
    zstr_sendx (server, "BIND", "ipc://@/hydra", NULL);
    
    hydra_client_verbose = verbose;
    hydra_client_t *client = hydra_client_new ("ipc://@/hydra", 500);
    hydra_client_fetch (client);
    hydra_client_destroy (&client);
    
    zactor_destroy (&server);
    //  @end
    printf ("OK\n");
}

